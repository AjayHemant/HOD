<!DOCTYPE html>
<html>
<head>
    <title>Flappy Bird Fullscreen</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            /* Full viewport coverage and reset margins */
            background-color: #000;
            display: block; 
            height: 100dvh; 
            width: 100vw;
            margin: 0;
            padding: 0;
            overflow: hidden; 
        }
        canvas {
            /* Force canvas to cover the entire body */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none; 
            /* Optional: Make canvas look sharp on high-density screens */
            image-rendering: crisp-edges;
            image-rendering: pixelated;
        }

    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas> 
    <audio id="music" src="background.mp3" loop></audio>
    <audio id="flap" src="flap.ogg"></audio>
    <audio id="score" src="score.ogg"></audio>
    <audio id="die" src="die.ogg"></audio>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- Scaling/Resizing Variables ---
        // Base dimensions for the game logic (Flappy Bird standard)
        const BASE_WIDTH = 288;
        const BASE_HEIGHT = 512;
        let scale = 1; // Current scaling factor

        // --- Game Physics Constants (Easily Tweakable) ---
        const GAME_GRAVITY = 0.2; // How fast the bird accelerates downward
        const FLAP_LIFT = 3.0;      // How high the bird jumps (applied as negative speed)

        function resizeCanvas() {
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;

            // 1. Set the internal canvas resolution to the window size
            canvas.width = windowWidth;
            canvas.height = windowHeight;

            // 2. Calculate the scale factor to fit the BASE dimensions into the new size
            const widthRatio = windowWidth / BASE_WIDTH;
            const heightRatio = windowHeight / BASE_HEIGHT;
            
            // Use the smaller ratio to ensure the entire game fits within the screen
            scale = Math.min(widthRatio, heightRatio); 
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); // Initial full screen setup
        // --- End Full Screen Resizing ---

        // Audio elements
        const music = document.getElementById('music');
        const flapSound = document.getElementById('flap');
        const scoreSound = document.getElementById('score');
        const dieSound = document.getElementById('die');

        // Game states
        const states = {
            START: 0,
            PLAYING: 1,
            GAME_OVER: 2
        };
        let currentState = states.START;

        // Game variables
        let frames = 0;
        let score = 0;
        let bestScore = localStorage.getItem('bestScore') || 0;

        // --- Bird properties (using constants and corrected collision) ---
        const bird = {
            x: 50,
            y: 150,
            width: 68,
            height: 48,
            
            // Tighter collision box dimensions and offset
            c_width: 55,     
            c_height: 35,    
            c_x_offset: 6,   
            c_y_offset: 5,   
            
            gravity: GAME_GRAVITY,
            jump: FLAP_LIFT,       
            speed: 0,
            rotation: 0,
            draw() {
                // Draw logic remains in BASE coordinates
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                ctx.rotate(this.rotation);
                ctx.drawImage(birdImage, -this.width / 2, -this.height / 2, this.width, this.height);
                ctx.restore();
            },
            update() {
                if (currentState === states.PLAYING) {
                    this.speed += this.gravity;
                    this.y += this.speed;
                    this.rotation = Math.min(Math.PI / 4, this.speed / 10);

                    // Ground collision (using BASE_HEIGHT)
                    if (this.y + this.height >= BASE_HEIGHT) {
                        this.y = BASE_HEIGHT - this.height;
                        changeStateToGameOver();
                    }
                }
            },
            flap() {
                this.speed = -this.jump;
                flapSound.play();
            }
        };

        // --- Pipe properties (collision logic updated) ---
        const pipes = {
            position: [],
            width: 53,
            height: 400,
            gap: 200,
            maxYPos: -150,
            dx: 2,
            reset() {
                this.position = [];
            },
            update() {
                if (currentState !== states.PLAYING) return;

                if (frames % 100 === 0) {
                    this.position.push({
                        x: BASE_WIDTH,
                        y: this.maxYPos * (Math.random() + 1)
                    });
                }

                for (let i = 0; i < this.position.length; i++) {
                    let p = this.position[i];
                    p.x -= this.dx;

                    let bottomPipeYPos = p.y + this.height + this.gap;

                    // --- Collision detection using tighter Bounding Box ---
                    // Calculate the bird's current TIGHTER collision box coordinates
                    const bird_c_x = bird.x + bird.c_x_offset;
                    const bird_c_y = bird.y + bird.c_y_offset;
                    const bird_c_w = bird.c_width;
                    const bird_c_h = bird.c_height;

                    // Check for collision with the top pipe
                    if (bird_c_x < p.x + this.width && 
                        bird_c_x + bird_c_w > p.x &&   
                        bird_c_y < p.y + this.height && 
                        bird_c_y + bird_c_h > p.y) {    
                        changeStateToGameOver();
                    }
                    
                    // Check for collision with the bottom pipe
                    if (bird_c_x < p.x + this.width &&
                        bird_c_x + bird_c_w > p.x &&
                        bird_c_y < bottomPipeYPos + this.height && 
                        bird_c_y + bird_c_h > bottomPipeYPos) {
                        changeStateToGameOver();
                    }

                    // Move pipes to the beginning
                    if (p.x + this.width <= 0) {
                        this.position.shift();
                        score++;
                        scoreSound.play();
                        bestScore = Math.max(score, bestScore);
                        localStorage.setItem('bestScore', bestScore);
                    }
                }
            },
            draw() {
                for (let i = 0; i < this.position.length; i++) {
                    let p = this.position[i];
                    let topYPos = p.y;
                    let bottomYPos = p.y + this.height + this.gap;

                    // Draw top pillar (flipped)
                    ctx.save();
                    ctx.translate(p.x + this.width, topYPos + this.height);
                    ctx.scale(-1, -1);
                    ctx.drawImage(pillarImage, 0, 0, this.width, this.height);
                    ctx.restore();

                    // Draw bottom pillar
                    ctx.drawImage(pillarImage, p.x, bottomYPos, this.width, this.height);
                }
            }
        };

        // Load images
        let imagesLoaded = 0;
        const birdImage = new Image();
        birdImage.src = 'bird.png';
        const pillarImage = new Image();
        pillarImage.src = 'pillar.png';
        const bgImage = new Image();
        bgImage.src = 'background.png';
        const goImage = new Image();
        goImage.src = 'gameover.png';

        const images = [birdImage, pillarImage, bgImage, goImage];
        let loadedCount = 0;
        images.forEach(image => {
            image.onload = () => {
                loadedCount++;
                if (loadedCount === images.length) {
                    gameLoop();
                }
            };
        });

        // Game loop
        function gameLoop() {
            update();
            draw();
            frames++;
            requestAnimationFrame(gameLoop);
        }

        function update() {
            bird.update();
            pipes.update();
        }

        // --- MODIFIED DRAW FUNCTION ---
        function draw() {
            // Clear the entire screen (now dynamically sized)
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Apply global transformation and translation
            ctx.save();
            // Calculate the offset to center the scaled game area
            const offsetX = (canvas.width - BASE_WIDTH * scale) / 2;
            const offsetY = (canvas.height - BASE_HEIGHT * scale) / 2;
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            // Check game state to decide background
            if (currentState !== states.GAME_OVER) {
                // Draw game elements in BASE coordinates
                ctx.drawImage(bgImage, 0, 0, BASE_WIDTH, BASE_HEIGHT);
                pipes.draw();
                bird.draw();
            } else {
                // On Game Over, draw a black background instead
                ctx.fillStyle = "#000";
                ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
            }
            
            // The score/UI is always drawn on top of everything
            drawScore();
            
            ctx.restore(); // Reset transformation for next frame
        }

        function drawScore() {
            // Note: score drawing is now scaled and translated along with the game via draw() function
            ctx.fillStyle = "#FFF";
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 2;
            ctx.font = "35px sans-serif";
            ctx.textAlign = "center";

            if (currentState === states.START) {
                ctx.strokeText("Click to Start", BASE_WIDTH / 2, BASE_HEIGHT / 2 - 50);
                ctx.fillText("Click to Start", BASE_WIDTH / 2, BASE_HEIGHT / 2 - 50);
            } else {
                ctx.strokeText(score, BASE_WIDTH / 2, 50);
                ctx.fillText(score, BASE_WIDTH / 2, 50);
            }
            if (currentState === states.GAME_OVER) {
                const goImageWidth = goImage.width / 2;
                const goImageHeight = goImage.height / 2;
                ctx.drawImage(goImage, BASE_WIDTH / 2 - goImageWidth / 2, BASE_HEIGHT / 2 - goImageHeight / 2 - 50, goImageWidth, goImageHeight);
                ctx.strokeText("Click to Restart", BASE_WIDTH / 2, BASE_HEIGHT / 2 + 50);
                ctx.fillText("Click to Restart", BASE_WIDTH / 2, BASE_HEIGHT / 2 + 50);
                ctx.strokeText(`Best: ${bestScore}`, BASE_WIDTH / 2, BASE_HEIGHT / 2 + 100);
                ctx.fillText(`Best: ${bestScore}`, BASE_WIDTH / 2, BASE_HEIGHT / 2 + 100);
            }
        }

        // Event listener
        canvas.addEventListener('click', () => {
            switch (currentState) {
                case states.START:
                    currentState = states.PLAYING;
                    music.play();
                    break;
                case states.PLAYING:
                    bird.flap();
                    break;
                case states.GAME_OVER:
                    bird.y = 150;
                    bird.speed = 0;
                    bird.rotation = 0;
                    pipes.reset();
                    score = 0;
                    currentState = states.START;
                    music.currentTime = 0;
                    music.pause();
                    break;
            }
        });

        function changeStateToGameOver() {
            if (currentState === states.PLAYING) {
                currentState = states.GAME_OVER;
                music.pause();
                dieSound.play();
            }
        }
    </script>
</body>
</html>
